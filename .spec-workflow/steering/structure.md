# Project Structure

## Directory Organization

```
yawn/
├── .spec-workflow/               # Specification workflow documents
│   └── steering/                 # Steering documents (product.md, tech.md, structure.md)
├── api/                         # Backend microservices (DDD-based)
│   ├── auth/                    # Authentication and authorization service
│   │   ├── internal/            # Internal implementation
│   │   │   ├── infrastructure/  # External dependencies and implementations
│   │   │   └── interfaces/     # Service interfaces and DTOs
│   │   ├── cmd/                 # CLI entry points
│   │   ├── pkg/                 # Shared packages
│   │   └── go.mod               # Go module definition
│   ├── workflows/               # Workflow execution service
│   │   ├── internal/
│   │   │   ├── infrastructure/  # Queue, storage, execution engine
│   │   │   └── interfaces/     # Workflow API definitions
│   │   ├── cmd/
│   │   └── go.mod
│   ├── scripts/                 # Script management service
│   │   ├── internal/
│   │   │   ├── infrastructure/  # Git integration, execution, storage
│   │   │   └── interfaces/     # Script API definitions
│   │   ├── cmd/
│   │   └── go.mod
│   ├── dashboards/              # Dashboard service
│   │   ├── internal/
│   │   │   ├── infrastructure/  # Puck data storage, rendering
│   │   │   └── interfaces/     # Dashboard API definitions
│   │   ├── cmd/
│   │   └── go.mod
│   └── shared/                  # Shared backend utilities and types
│       ├── pkg/                 # Shared packages (database, auth, etc.)
│       └── go.mod
├── web/                         # Frontend applications
│   ├── core/                    # Core frontend application (shell)
│   │   ├── src/
│   │   │   ├── components/      # Shared components
│   │   │   ├── hooks/           # Custom React hooks
│   │   │   ├── utils/           # Utility functions
│   │   │   ├── types/           # TypeScript types (from tygo)
│   │   │   └── App.tsx          # Main application entry
│   │   ├── package.json
│   │   └── vite.config.ts
│   ├── scripts-app/             # Scripts micro-frontend
│   │   ├── src/
│   │   │   ├── components/      # Monaco editor, file browser, git UI
│   │   │   ├── hooks/           # Script-specific hooks
│   │   │   ├── pages/           # Script editor, browser, settings
│   │   │   └── utils/           # Script-specific utilities (types from @/types)
│   │   └── package.json
│   ├── workflows-app/           # Workflows micro-frontend
│   │   ├── src/
│   │   │   ├── components/      # Flow builder, node palette, execution UI
│   │   │   ├── hooks/           # Workflow-specific hooks
│   │   │   ├── pages/           # Workflow editor, execution history
│   │   │   └── utils/           # Workflow-specific utilities (types from @/types)
│   │   └── package.json
│   ├── dashboards-app/          # Dashboards micro-frontend
│   │   ├── src/
│   │   │   ├── components/      # Puck editor, dashboard viewer
│   │   │   ├── hooks/           # Dashboard-specific hooks
│   │   │   ├── pages/           # Dashboard editor, viewer
│   │   │   └── utils/           # Dashboard-specific utilities (types from @/types)
│   │   └── package.json
│   └── shared-ui/               # Shared UI components
│       ├── src/
│       │   ├── components/      # Reusable UI components
│       │   ├── hooks/           # Shared hooks
│       │   ├── utils/           # UI utilities
│       │   └── themes/          # Theme definitions
│       └── package.json
├── templates/                   # Moonrepo templates
│   ├── api-service/             # API microservice template
│   │   ├── internal/
│   │   │   ├── domain/
│   │   │   ├── infrastructure/
│   │   │   └── interfaces/
│   │   ├── cmd/
│   │   └── template.yaml
│   ├── micro-frontend/          # Micro-frontend template
│   │   ├── src/
│   │   ├── package.json
│   │   └── template.yaml
│   └── component/               # Reusable component template
│       ├── src/
│       ├── package.json
│       └── template.yaml
├── types/                       # Shared type definitions (single source of truth)
│   ├── domain/                  # Go domain types - ONLY source of domain models
│   │   ├── auth.go              # Authentication and authorization types
│   │   ├── workflows.go         # Workflow and execution types
│   │   ├── scripts.go           # Script and versioning types
│   │   └── dashboards.go        # Dashboard and UI types
│   └── generated/               # Auto-generated TypeScript types from Go
│       └── types.ts             # Generated by tygo from types/domain/
├── moon.yml                     # Moonrepo configuration
├── .mise.toml                   # Development environment configuration
├── docker-compose.yml           # Local development setup
├── README.md                    # Project documentation
└── .gitignore                   # Git ignore rules
```

## Naming Conventions

### Files
- **Go Files**: `snake_case.go` (e.g., `user_service.go`, `workflow_executor.go`)
- **TypeScript Files**: `kebab-case.ts` or `kebab-case.tsx` (e.g., `workflow-builder.tsx`, `script-editor.tsx`)
- **Component Files**: `kebab-case.tsx` (e.g., `monaco-editor.tsx`, `puck-dashboard.tsx`)
- **Test Files**: `[filename]_test.go` for Go, `[filename].test.ts` for TypeScript
- **Configuration Files**: `kebab-case.yaml` or `kebab-case.toml`

### Code
- **Go Types/Structs**: `PascalCase` (e.g., `Workflow`, `ScriptExecution`)
- **Go Functions/Methods**: `PascalCase` (e.g., `ExecuteWorkflow`, `CreateScript`)
- **Go Variables**: `camelCase` (e.g., `workflowID`, `scriptResult`)
- **Go Constants**: `PascalCase` (e.g., `MaxConcurrentExecutions`, `DefaultTimeout`)
- **TypeScript Types/Interfaces**: `PascalCase` (e.g., `WorkflowNode`, `DashboardConfig`)
- **TypeScript Functions**: `camelCase` (e.g., `executeWorkflow`, `createScript`)
- **TypeScript Variables**: `camelCase` (e.g., `workflowId`, `scriptResult`)
- **TypeScript Constants**: `UPPER_SNAKE_CASE` (e.g., `MAX_CONCURRENT_EXECUTIONS`)

## Import Patterns

### Import Order
1. External dependencies (React, third-party libraries)
2. Internal shared modules (@/shared, @/types)
3. Feature-specific modules (relative imports within the same micro-frontend)
4. Style imports (CSS, SCSS)

### Module/Package Organization
- **Go**: Use absolute imports within each service:
  - `github.com/yawn/shared/domain` for shared domain types
  - `github.com/yawn/shared/pkg` for shared packages
  - Service-specific imports for infrastructure and interfaces
- **TypeScript**: Use path aliases for clean imports:
  - `@/shared/components` for shared UI components
  - `@/types` for TypeScript types (generated from Go)
  - `@/hooks` for shared hooks
  - Relative imports for feature-specific modules

### Type System Architecture
- **Single Source of Truth**: `types/domain/` contains all Go domain types
- **No Redundancy**: Services import from `types/domain/` instead of maintaining their own domain types
- **Type Generation**: `types/generated/` contains TypeScript types auto-generated from Go types using tygo
- **Frontend Types**: Micro-frontends import from `types/generated/` for end-to-end type safety
- **Service-Specific Types**: Implementation details can exist in `internal/` but should not duplicate domain models

## Code Structure Patterns

### Module/Class Organization
```typescript
// TypeScript component file structure
import React from 'react';
import { useSomeHook } from '@/hooks';
import { SomeComponent } from '@/shared/components';
import { SomeType } from '@/types';

const CONSTANTS = {
  MAX_ITEMS: 100,
  TIMEOUT: 5000,
};

export const MyComponent: React.FC = () => {
  // Component logic
  return <div>...</div>;
};

export default MyComponent;
```

```go
// Go service file structure with fx dependency injection
package service

import (
  "context"
  "fmt"
  
  "go.uber.org/fx"
  
  "github.com/yawn/shared/domain"
  "github.com/yawn/shared/pkg/logger"
)

type Service struct {
  repo Repository
  logger logger.Logger
}

// Constructor function for fx dependency injection
func NewService(repo Repository, logger logger.Logger) *Service {
  return &Service{
    repo: repo,
    logger: logger,
  }
}

// Service module for fx application
var ServiceModule = fx.Module("service",
  fx.Provide(
    NewService,              // Provide service instance
    NewRepository,           // Provide repository dependency
    NewDatabase,             // Provide database dependency
  ),
  fx.Invoke(
    RegisterServiceRoutes,   // Invoke function to register routes
    StartServiceWorkers,     // Invoke function to start background workers
  ),
)

func (s *Service) ExecuteWorkflow(ctx context.Context, req *ExecuteWorkflowRequest) (*ExecuteWorkflowResponse, error) {
  // Service logic
}

// Main application setup
func main() {
  app := fx.New(
    ServiceModule,
    // Other modules...
  )
  
  app.Run()
}
```

### Function/Method Organization
- **Input validation first**
- **Core logic in the middle**
- **Error handling throughout**
- **Clear return points**
- **Logging for important operations**

### File Organization Principles
- **One main component/class per file**
- **Related utility functions grouped together**
- **Public API clearly exported**
- **Implementation details kept private**

## Code Organization Principles

1. **Single Responsibility**: Each file should have one clear purpose
2. **Domain-Driven Design**: Separate business logic from infrastructure concerns
3. **Micro-frontend Architecture**: Independent development of major features
4. **Type-First Development**: Go types as source of truth with auto-generated TypeScript
5. **Dependency Injection**: All services use fx for dependency management
6. **Consistency**: Follow established patterns across the codebase

## fx Dependency Injection Patterns

### Module Structure
- **fx.Module**: Group related dependencies and invocations
- **fx.Provide**: Register constructor functions for dependencies
- **fx.Invoke**: Execute functions that use provided dependencies
- **fx.Annotate**: Add metadata to dependencies for advanced use cases

### Constructor Functions
- **Constructor Pattern**: Functions that create and return service instances
- **Interface Dependencies**: Depend on interfaces, not concrete implementations
- **Optional Dependencies**: Use fx.Optional for non-required dependencies
- **Lifecycle Hooks**: Use fx.Hook for startup and shutdown operations

### Application Structure
```go
// Main application setup
func main() {
    app := fx.New(
        // Core modules
        DatabaseModule,
        AuthModule,
        WorkflowModule,
        
        // Application modules
        HTTPServerModule,
        QueueModule,
        
        // Lifecycle hooks
        fx.Invoke(registerRoutes),
        fx.Invoke(startWorkers),
    )
    
    app.Run()
}
```

## Module Boundaries

### Backend Service Boundaries
- **Auth Service**: Handles authentication, authorization, and user management
- **Workflows Service**: Manages workflow definitions, execution, and monitoring
- **Scripts Service**: Handles script versioning, execution, and Git integration
- **Dashboards Service**: Manages dashboard configurations and data serving
- **Shared**: Common utilities, database connections, and cross-cutting concerns

### Frontend Micro-frontend Boundaries
- **Core App**: Shell application providing navigation and micro-frontend loading
- **Scripts App**: Independent script editing and management interface
- **Workflows App**: Visual workflow builder and execution monitoring
- **Dashboards App**: Low-code dashboard editor and viewer
- **Shared UI**: Reusable components and utilities

### Dependency Rules
- Frontend micro-frontends can depend on Shared UI and types
- Backend services can depend on Shared packages and types
- All services use fx for dependency injection - no manual dependency management
- No circular dependencies between services or micro-frontends
- Types flow from Go to TypeScript, not vice versa
- Services import domain types from `types/domain/` (single source of truth)
- Dependencies are provided through fx modules and constructors

## Code Size Guidelines

- **File Size**: Maximum 500 lines per file (split larger files)
- **Function Size**: Maximum 50 lines per function (extract complex logic)
- **Component Size**: Maximum 300 lines per component (split into smaller components)
- **Complexity**: Maximum cyclomatic complexity of 10 per function
- **Nesting Depth**: Maximum 4 levels of nesting

## Documentation Standards

- **Public APIs**: All exported functions and types must have Go doc comments
- **Complex Logic**: Include inline comments for non-obvious algorithms
- **README Files**: Each major service and micro-frontend should have a README
- **Type Safety**: Leverage Go and TypeScript type systems for self-documenting code
- **Examples**: Provide usage examples for complex APIs

## Security and Compliance Structure

### Security Boundaries
- **Script Execution**: Isolated using nsjail containers
- **User Authentication**: Centralized in auth service with JWT tokens
- **Data Isolation**: Tenant-specific data separation in database
- **API Security**: Rate limiting, input validation, and authentication middleware

### Compliance Considerations
- **Audit Logging**: All user actions logged for compliance
- **Data Encryption**: Sensitive data encrypted at rest and in transit
- **Access Control**: RBAC implemented at service level
- **GDPR Compliance**: User data management and deletion capabilities

## Development Environment Structure

### Local Development
- **SQLite**: Default database for local development
- **Docker Compose**: Local service orchestration
- **Hot Reload**: Air for Go services, Vite for frontend
- **Tool Management**: mise for consistent development tools

### Build and Deployment
- **Single Binary**: Each service builds to standalone binary
- **Docker Support**: Containerized deployment options
- **Kubernetes Ready**: Microservice architecture supports orchestration
- **Multi-Platform**: AMD64 and ARM64 support